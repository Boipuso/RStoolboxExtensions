unique_values <- unique_values[!is.na(unique_values)]
# create an empty list to store polygons while looping
polygons_list <- list()
# loop over unique values (classes)
for (value in unique_values) {
# create a binary raster for each class
binary_raster <- ifel(class_img[[class_col]] == value, 1, NA_integer_)
# convert binary raster to polygons
polygons <- as.polygons(binary_raster)
# convert polygons to sf object
sf_polygons <- st_as_sf(polygons)
# add polygons to the list for the environment output
polygons_list[[as.character(value)]] <- sf_polygons
# if specified by the user, save the polygons in a local output folder
if(saveLoc == TRUE) {
# create a directory to save the polygons if it doesn't exist already
if (!dir.exists(out_dir)) {
dir.create(out_dir)
}
file_name <- paste0(out_dir,"/", as.character(value),".", datatype)
st_write(sf_polygons, file_name, append = append)
}
}
return(polygons_list)
}
tester <- extr_polygons(class_img, saveLoc = FALSE, out_dir = "testohyeah")
extr_rasters <- function(raster,
polygon_list,
saveLoc = FALSE,
out_dir = "raster_masked",
overwrite = TRUE,
datatype = "tif") {
#### validating the input and stop if something is wrong ####
if (missing(raster)) {
stop("'raster' input missing")
}
if (missing(polygon_list)) {
stop("'polygon_list' input missing")
}
if (!is.character(out_dir)) {
stop("Parameter 'out_dir' must be a character.")
}
if (!is.character(datatype)) {
stop("Parameter 'datatype' must be a character.")
}
# check if polygon_list is a list of polygons or multipolygons
if (!all(sapply(polygon_list, function(x) inherits(x, c("Polygon", "MultiPolygon"))))) {
stop("Input 'polygon_list' must be a list of polygons or multipolygons.")
}
##############################################################
# create empty list to store the results
masked_raster_list <- list()
# loop over the entries of the polygon list
for (name in names(polygon_list)) {
# convert data frame to sf object
polygon_sf <- st_as_sf(polygon_list[[name]])
# crop and mask the raster
cropped_raster <- crop(raster, polygon_sf)
masked_raster <- mask(cropped_raster, polygon_sf)
# add raster to the list for output in the environment
masked_raster_list[[name]] <- masked_raster
# if specified by the user, save the polygons in a local output folder
if(saveLoc == TRUE) {
# create a directory to save the polygons if it doesn't exist already
if (!dir.exists(out_dir)) {
dir.create(out_dir)
}
# create filenames for local saving when writing the output rasters
filename <- file.path(out_dir, paste0("/", name, ".", datatype))
# writing the rasters to safe them locally
writeRaster(masked_raster, filename, overwrite = overwrite)
}
}
return(masked_raster_list)
}
testRasters <- extr_rasters(class_img, tester)
class(tester)
extr_rasters <- function(raster,
polygon_list,
saveLoc = FALSE,
out_dir = "raster_masked",
overwrite = TRUE,
datatype = "tif") {
#### validating the input and stop if something is wrong ####
if (missing(raster)) {
stop("'raster' input missing")
}
if (missing(polygon_list)) {
stop("'polygon_list' input missing")
}
if (!is.character(out_dir)) {
stop("Parameter 'out_dir' must be a character.")
}
if (!is.character(datatype)) {
stop("Parameter 'datatype' must be a character.")
}
# # check if polygon_list is a list of polygons or multipolygons
# if (!all(sapply(polygon_list, function(x) inherits(x, c("Polygon", "MultiPolygon"))))) {
#   stop("Input 'polygon_list' must be a list of polygons or multipolygons.")
# }
##############################################################
# create empty list to store the results
masked_raster_list <- list()
# loop over the entries of the polygon list
for (name in names(polygon_list)) {
# convert data frame to sf object
polygon_sf <- st_as_sf(polygon_list[[name]])
# crop and mask the raster
cropped_raster <- crop(raster, polygon_sf)
masked_raster <- mask(cropped_raster, polygon_sf)
# add raster to the list for output in the environment
masked_raster_list[[name]] <- masked_raster
# if specified by the user, save the polygons in a local output folder
if(saveLoc == TRUE) {
# create a directory to save the polygons if it doesn't exist already
if (!dir.exists(out_dir)) {
dir.create(out_dir)
}
# create filenames for local saving when writing the output rasters
filename <- file.path(out_dir, paste0("/", name, ".", datatype))
# writing the rasters to safe them locally
writeRaster(masked_raster, filename, overwrite = overwrite)
}
}
return(masked_raster_list)
}
testRasters <- extr_rasters(class_img, tester)
terra::plot(testRasters$afforestation)
rm(extr_polygons())
rm(extr_polygons
rm(extr_polygons)
View(extr_polygons)
getwd()
roxygen2::roxygenise("C:/Users/henni/Documents/Git/RStoolboxExtensions")
rm(list = c("extr_polygons", "extr_rasters"))
roxygen2::roxygenise("C:/Users/henni/Documents/Git/RStoolboxExtensions")
Sebangau_renamed <- rename_bands(Sebangau, sensor = "Landsat8", subsetting = FALSE)
Sebangau_renamed <- rename_bands(Sebangau, sensor = "Landsat8", subsetting = TRUE)
Sebangau_indices <- calc_indices(Sebangau_renamed, indices= c("ndsi"))
terra::plot(Sebangau_indices$NDSI)
ndsi_test <- points_superClass(Sebangau_indices, feature_collection, "landcover", trainPartition = 0.66)
terra::plot(ndsi_test$map)
Sebangau_indices <- calc_indices(Sebangau_renamed, indices= c("savi"), L = 0.5)
terra::plot(Sebangau_indices$SAVI)
savi <- terra::subset(Sebangau_indices, "SAVI")
savi_test <- points_superClass(savi, feature_collection, "landcover", trainPartition = 0.66)
terra::plot(savi_test$map)
Sebangau_indices <- calc_indices(Sebangau_renamed, indices= c("evi"), L = 0.5)
terra::plot(Sebangau_indices$EVI)
head(savi)
head(ndsi)
blue <- terra::subset(Sebangau_indices, "Blue")
head(blue)
evi <- terra::subset(Sebangau_indices, "EVI")
head(evi)
mean(evi)
mean(ndsi)
mean(savi)
mean(blue)
calc_indices <- function(raster, indices = c("ndvi", "ndwi"), L = NULL) {
#### validating the input and stop if something is wrong ####
if (missing(raster)) {
stop("raster input missing")
}
if (!is.character(indices)) {
stop("Parameter 'indices' must be a character vector.")
}
# handle case sensibility of indices input
indices = tolower(indices)
# check if all index names are valid
valid_indices <- c("ndvi", "ndwi", "ndbi", "ndmi", "ndsi", "evi", "ewi", "sr", "savi")
invalid_indices <- setdiff(indices, valid_indices)
# stop and print error message if they are not valid
if (length(invalid_indices) > 0) {
stop(paste("Invalid index names:", paste(invalid_indices, collapse = ", ")))
}
##############################################################
# handle case sensitivity of raster names but store old names
original_names <- names(raster)
names(raster) <- tolower(names(raster))
# create empty list and string to store index values and their respective names
index_values <- list()
index_names <- c()
# calculate the specified indices if the bands needed are provided
if ("ndvi" %in% indices) {
if (!all(c("red", "nir") %in% names(raster))) {
stop("Input raster must have 'red' and 'nir' bands for NDVI calculation.")
}
message("Calculating NDVI ...")
index_values$NDVI <- (raster$nir - raster$red) / (raster$nir + raster$red)
index_names <- c(index_names, "NDVI")
message("Done")
}
if ("ndwi" %in% indices) {
if (!all(c("green", "nir") %in% names(raster))) {
stop("Input raster must have 'green' and 'nir' bands for NDWI calculation.")
}
message("Calculating NDWI ...")
index_values$NDWI <- (raster$green - raster$nir) / (raster$green + raster$nir)
index_names <- c(index_names, "NDWI")
message("Done")
}
if ("ndbi" %in% indices) {
if (!all(c("swir1", "nir") %in% names(raster))) {
stop("Input raster must have 'swir1' and 'nir' bands for NDBI calculation.")
}
message("Calculating NDBI ...")
index_values$NDBI <- (raster$swir1 - raster$nir) / (raster$swir1 + raster$nir)
index_names <- c(index_names, "NDBI")
message("Done")
}
if ("ndmi" %in% indices) {
if (!all(c("nir", "swir1") %in% names(raster))) {
stop("Input raster must have 'nir' and 'swir1' bands for NDMI calculation.")
}
message("Calculating NDMI ...")
index_values$NDMI <- (raster$nir - raster$swir1) / (raster$nir + raster$swir1)
index_names <- c(index_names, "NDMI")
message("Done")
}
if ("ndsi" %in% indices) {
if (!all(c("green", "swir1") %in% names(raster))) {
stop("Input raster must have 'green' and 'swir1' bands for NDSI calculation.")
}
message("Calculating NDSI ...")
index_values$NDSI <- (raster$green - raster$swir1) / (raster$green + raster$swir1)
index_names <- c(index_names, "NDSI")
message("Done")
}
if ("evi" %in% indices) {
if (!all(c("blue", "red", "nir") %in% names(raster))) {
stop("Input raster must have 'blue', 'red' and 'nir' bands for EVI calculation.")
}
message("Calculating EVI ...")
index_values$EVI <- (2.5 * (raster$nir - raster$red) / (raster$nir + (6 * raster$red) - (7.5 * raster$blue) + 1))
index_names <- c(index_names, "EVI")
message("Done")
}
if ("ewi" %in% indices) {
if (!all(c("green", "swir1") %in% names(raster))) {
stop("Input raster must have 'green' and 'swir1' bands for EWI calculation.")
}
message("Calculating EWI ...")
index_values$EWI <- (2.5 * (raster$green - raster$swir1) / (raster$green + (2.4 * raster$swir1) + 1))
index_names <- c(index_names, "EWI")
message("Done")
}
if ("sr" %in% indices) {
if (!all(c("red", "nir") %in% names(raster))) {
stop("Input raster must have 'red' and 'nir' bands for SR calculation.")
}
message("Calculating SR ...")
index_values$SR <- raster$nir / raster$red
index_names <- c(index_names, "SR")
message("Done")
}
if ("savi" %in% indices) {
if (!all(c("green", "swir1") %in% names(raster))) {
stop("Input raster must have 'green' and 'swir1' bands for SAVI calculation.")
}
if (is.null(L)) {
stop("Input 'L' must be specified for calculating the SAVI")
}
message("Calculating SAVI ...")
index_values$SAVI <- (raster$nir - raster$red) / ((raster$nir + raster$red + L) * (1 + L))
index_names <- c(index_names, "SAVI")
message("Done")
}
# return to the old colnames
names(raster) <- original_names
# add the specified indices to the raster
for (index_name in names(index_values)) {
add(raster) <- index_values[[index_name]]
}
# name them in the raster
names(raster)[(nlyr(raster) - length(index_values) + 1):nlyr(raster)] <- names(index_values)
# # Function to remove NA values from a raster
# remove_NA <- function(raster) {
#   return(raster[!is.na(raster)])
# }
#
# #remove Na from every new index layer
# for (name in names(index_values)) {
#   raster[[name]] <- remove_NA(raster[[name]])
# }
return(raster)
}
Sebangau_indices <- calc_indices(Sebangau_renamed, indices= c("evi"), L = 0.5)
terra::plot(Sebangau_indices$EVI)
terra::plot(Sebangau_indices$EVI)
evi <- terra::subset(Sebangau_indices, "EVI")
mean(evi)
Sebangau_indices <- calc_indices(Sebangau_renamed, indices= c("ewi"), L = 0.5)
terra::plot(Sebangau_indices$EWI)
ewi <- terra::subset(Sebangau_indices, "EVI")
ewi <- terra::subset(Sebangau_indices, "EWI")
mean(ewi)
terra::plot(Sebangau_indices$Blue)
terra::plot(Sebangau_indices$Red)
mean(Sebangau_indices$Red)
# retrieve the sample raster data from the package
# the sample data consists of 2 rasters of the Sebangau Nationalpark in Borneo from the years 20115 and 2023 and training points for change detection analyses.
Sebangau15 <- system.file("extdata", "Sebangau15.tif", package = "RStoolboxExtensions")
Sebangau15 <- rast_sample_read(Sebangau15)
Sebangau23 <- system.file("extdata", "Sebangau23.tif", package = "RStoolboxExtensions")
Sebangau23 <- rast_sample_read(Sebangau23)
# read sample sf file of the RStoolboxExtensions package
trainPoints <- system.file("extdata", "trainPoints.geojson", package = "RStoolboxExtensions")
trainPoints <- sf_sample_read(trainPoints)
names(trainPoints)
getwd()
roxygen2::roxygenise("C:/Users/henni/Documents/Git/RStoolboxExtensions")
roxygen2::roxygenise("C:/Users/henni/Documents/Git/RStoolboxExtensions")
# specify your input features
# here we choose that we do want to rename and subset the bands (renaming the bands is prerequisite for calculating indices) and also we want to calculate the indices NDVI and NDWI to improve our classification results
asC <- auto_superClass(img = Sebangau,
img2 = Sebangau_15,
train_features = feature_collection,
responseCol = "landcover",
rename_bands = TRUE,
subsetting = TRUE,
sensor = "Landsat8",
calc_indices = FALSE,
indices = c("ndvi", "ndwi", "ndbi", "ndmi", "ndsi", "ewi", "sr", "savi"),
trainPartition = 0.66
)
library(RStoolboxExtensions)
# specify your input features
# here we choose that we do want to rename and subset the bands (renaming the bands is prerequisite for calculating indices) and also we want to calculate the indices NDVI and NDWI to improve our classification results
asC <- auto_superClass(img = Sebangau,
img2 = Sebangau_15,
train_features = feature_collection,
responseCol = "landcover",
rename_bands = TRUE,
subsetting = TRUE,
sensor = "Landsat8",
calc_indices = FALSE,
indices = c("ndvi", "ndwi", "ndbi", "ndmi", "ndsi", "ewi", "sr", "savi"),
trainPartition = 0.66
)
# specify your input features
# here we choose that we do want to rename and subset the bands (renaming the bands is prerequisite for calculating indices) and also we want to calculate the indices NDVI and NDWI to improve our classification results
asC <- auto_superClass(img = Sebangau,
img2 = Sebangau_15,
train_features = trainPoints,
responseCol = "landcover",
rename_bands = TRUE,
subsetting = TRUE,
sensor = "Landsat8",
calc_indices = FALSE,
indices = c("ndvi", "ndwi", "ndbi", "ndmi", "ndsi", "ewi", "sr", "savi"),
trainPartition = 0.66
)
# specify your input features
# here we choose that we do want to rename and subset the bands (renaming the bands is prerequisite for calculating indices) and also we want to calculate the indices NDVI and NDWI to improve our classification results
asC <- auto_superClass(img = Sebangau15,
img2 = Sebangau23,
train_features = trainPoints,
responseCol = "landcover",
rename_bands = TRUE,
subsetting = TRUE,
sensor = "Landsat8",
calc_indices = FALSE,
indices = c("ndvi", "ndwi", "ndbi", "ndmi", "ndsi", "ewi", "sr", "savi"),
trainPartition = 0.66
)
# import the scene and features
Sebangau <- terra::rast('C:/Users/henni/Documents/Git/Eagle_1st_Semester/R_Project/data/L8_23median.tif')
Sebangau_15 <- terra::rast('C:/Users/henni/Documents/Git/Eagle_1st_Semester/R_Project/data/L8_15median.tif')
feature_collection <- sf::st_read("C:/Users/henni/Documents/Git/Eagle_1st_Semester/R_Project/data/exported_feature_collection.geojson")
# reassigning the landcvoer values to be a character description of the class instead of numerical values
landcover <- c('forest','nonforest','afforestation','deforestation')
feature_collection$landcover <- landcover[feature_collection$landcover]
# specify your input features
# here we choose that we do want to rename and subset the bands (renaming the bands is prerequisite for calculating indices) and also we want to calculate the indices NDVI and NDWI to improve our classification results
asC <- auto_superClass(img = Sebangau,
img2 = Sebangau_15,
train_features = feature_collection,
responseCol = "landcover",
rename_bands = TRUE,
subsetting = TRUE,
sensor = "Landsat8",
calc_indices = FALSE,
indices = c("ndvi", "ndwi", "ndbi", "ndmi", "ndsi", "ewi", "sr", "savi"),
trainPartition = 0.66
)
# specify your input features
# here we choose that we do want to rename and subset the bands (renaming the bands is prerequisite for calculating indices) and also we want to calculate the indices NDVI and NDWI to improve our classification results
asC <- auto_superClass(img = Sebangau,
img2 = Sebangau_15,
train_features = feature_collection,
responseCol = "landcover",
rename_bands = TRUE,
subsetting = TRUE,
sensor = "Landsat8",
calc_indices = TRUE,
indices = c("ndvi", "ndwi", "ndbi", "ndmi", "ndsi", "ewi", "sr", "savi"),
trainPartition = 0.66
)
roxygen2::roxygenise("C:/Users/henni/Documents/Git/RStoolboxExtensions")
# import the scene and features
Sebangau <- terra::rast('C:/Users/henni/Documents/Git/Eagle_1st_Semester/R_Project/data/L8_23median.tif')
Sebangau_15 <- terra::rast('C:/Users/henni/Documents/Git/Eagle_1st_Semester/R_Project/data/L8_15median.tif')
feature_collection <- sf::st_read("C:/Users/henni/Documents/Git/Eagle_1st_Semester/R_Project/data/exported_feature_collection.geojson")
# reassigning the landcvoer values to be a character description of the class instead of numerical values
landcover <- c('forest','nonforest','afforestation','deforestation')
feature_collection$landcover <- landcover[feature_collection$landcover]
# specify your input features
# here we choose that we do want to rename and subset the bands (renaming the bands is prerequisite for calculating indices) and also we want to calculate the indices NDVI and NDWI to improve our classification results
asC <- auto_superClass(img = Sebangau,
img2 = Sebangau_15,
train_features = feature_collection,
responseCol = "landcover",
rename_bands = TRUE,
subsetting = TRUE,
sensor = "Landsat8",
calc_indices = TRUE,
indices = c("ndvi", "ndwi", "ndbi", "ndmi", "ndsi", "ewi", "sr", "savi"),
L = 0.5,
trainPartition = 0.66
)
library(RStoolboxExtensions)
# specify your input features
# here we choose that we do want to rename and subset the bands (renaming the bands is prerequisite for calculating indices) and also we want to calculate the indices NDVI and NDWI to improve our classification results
asC <- auto_superClass(img = Sebangau,
img2 = Sebangau_15,
train_features = feature_collection,
responseCol = "landcover",
rename_bands = TRUE,
subsetting = TRUE,
sensor = "Landsat8",
calc_indices = TRUE,
indices = c("ndvi", "ndwi", "ndbi", "ndmi", "ndsi", "ewi", "sr", "savi"),
L = 0.5,
trainPartition = 0.66
)
# specify your input features
# here we choose that we do want to rename and subset the bands (renaming the bands is prerequisite for calculating indices) and also we want to calculate the indices NDVI and NDWI to improve our classification results
asC <- auto_superClass(img = Sebangau,
img2 = Sebangau_15,
train_features = feature_collection,
responseCol = "landcover",
rename_bands = TRUE,
subsetting = TRUE,
sensor = "Landsat8",
calc_indices = FALSE,
indices = c("ndvi", "ndwi", "ndbi", "ndmi", "ndsi", "ewi", "sr", "savi"),
L = 0.5,
trainPartition = 0.66
)
class_img <- extr_polygons(class_img, saveLoc = FALSE)
class_img <-asC$superClass_img
extrPols <- extr_polygons(class_img, saveLoc = FALSE)
terra::plot(extrPols$forest)
terra::plot(extrPols$forest)
getwd()
terra::plot(extrPols$afforestation)
getwd()
terra::plot(asC$superClass_img)
extrPols_NEW <- extr_polygons(class_img, saveLoc = TRUE)
extr_polygons <- function(class_img,
saveLoc = TRUE,
datatype = "gpkg",
class_col = "class",
append = FALSE,
out_dir = "class_polygons") {
#### validating the input and stop if something is wrong ####
if (missing(class_img)) {
stop("'class_img' input missing")
}
if (!is.character(datatype)) {
stop("Parameter 'datatype' must be a character.")
}
if (!is.character(class_col)) {
stop("Parameter 'class_col' must be a character.")
}
if (!is.character(out_dir)) {
stop("Parameter 'out_dir' must be a character.")
}
# check if 'class_col' exists in the raster colnames
if (!(class_col %in% names(class_img))) {
stop("Specified 'class_col' does not exist in the raster attributes. Please provide a valid column name.")
}
##############################################################
# get unique values in the raster to loop over them
unique_values <- unique(class_img[[class_col]])
# remove NA values if present
unique_values <- unique_values[!is.na(unique_values)]
# create an empty list to store polygons while looping
polygons_list <- list()
# create a directory to save the polygons if it doesn't exist already
if (!dir.exists(out_dir)) {
dir.create(out_dir)
}
# loop over unique values (classes) to create binary raster for each class and convert them to polygons
for (value in unique_values) {
# create a binary raster for each class
binary_raster <- ifel(class_img[[class_col]] == value, 1, NA_integer_)
# convert binary raster to polygons
polygons <- as.polygons(binary_raster)
# convert polygons to sf object
sf_polygons <- st_as_sf(polygons)
# add polygons to the list for the environment output
polygons_list[[as.character(value)]] <- sf_polygons
# if specified by the user, save the polygons in a local output folder
file_name <- paste0(out_dir,"/", as.character(value),".", datatype)
st_write(sf_polygons, file_name, append = append)
}
return(polygons_list)
}
extrPols_new <- extr_polygons(class_img, saveLoc = TRUE)
gc()
